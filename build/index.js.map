{"version":3,"sources":["webpack://Swich/webpack/universalModuleDefinition","webpack://Swich/webpack/bootstrap","webpack://Swich/webpack/runtime/define property getters","webpack://Swich/webpack/runtime/hasOwnProperty shorthand","webpack://Swich/webpack/runtime/make namespace object","webpack://Swich/./src/lib/index.ts"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","defaultMatcher","config","valueToMatch","pattern","RegExp","test","catchFunctionErrors","acceptTruthyFunctionReturn","error","strict","defaultResultGetter","result","resultToBeSet","runResultFunction","replacement","performReplaceOnRegex","replace","getRegexResult","createSwich","returnMany","defaultReturnMany","defaultStrict","defaultAcceptTruthyFunctionReturn","defaultCatchFunctionErrors","defaultPerformReplaceOnRegex","defaultRunResultFunction","stopFallThrough","defaultStopFallThrough","matcher","defaultMatcherValue","resultGetter","defaultResultGetterValue","patterns","found","setResult","setFound","push","verifyValue","getResult","fallingThrough","forEach","matchArr","index","fallthrough","length","undefined","gt","compareValue","gte","lt","lte"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Swich\"] = factory();\n\telse\n\t\troot[\"Swich\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Object } from \"ts-toolbelt\";\n\ntype Pattern<TValue> =\n  | RegExp\n  | ((value: TValue) => boolean)\n  | ((value: TValue) => any)\n  | any;\ntype Result<TValue, TOutput> = TOutput | ((param: TValue) => TOutput);\ntype CaseElement<TValue, TOutput> = [\n  Pattern<TValue>,\n  Result<TValue, TOutput>,\n  true?\n];\ntype DefaultCaseElement<TValue, TOutput> = [Result<TValue, TOutput>];\ntype CaseElements<TValue, TOutput> = (\n  | CaseElement<TValue, TOutput>\n  | DefaultCaseElement<TValue, TOutput>\n)[];\n\ntype Matcher<TValue, TOutput> = (\n  config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n) => (valueToMatch: TValue, pattern: Pattern<TValue>) => boolean;\ntype ResultGetter<TValue, TOutput> = (\n  config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n) => (valueToMatch: TValue, pattern: Pattern<TValue>, result: any) => TOutput;\n\ntype Config<TValue, TOutput> = {\n  returnMany: boolean;\n  strict: boolean;\n  acceptTruthyFunctionReturn: boolean;\n  catchFunctionErrors: boolean;\n  performReplaceOnRegex: boolean;\n  runResultFunction: boolean;\n  stopFallThrough: boolean;\n  matcher: Matcher<TValue, TOutput>;\n  resultGetter: ResultGetter<TValue, TOutput>;\n};\ntype BasicConfig<TValue, TOutput> = Object.Omit<\n  Config<TValue, TOutput>,\n  \"matcher\" | \"resultGetter\"\n>;\n\nexport const defaultMatcher =\n  <TValue, TOutput>(config: BasicConfig<TValue, TOutput>) =>\n  (valueToMatch: TValue, pattern: Pattern<TValue>): boolean => {\n    if (pattern instanceof RegExp) {\n      return typeof valueToMatch === \"string\"\n        ? pattern.test(valueToMatch)\n        : false;\n    }\n    if (typeof pattern === \"function\") {\n      if (config.catchFunctionErrors) {\n        try {\n          if (!config.acceptTruthyFunctionReturn) {\n            return pattern(valueToMatch) === true;\n          } else {\n            return !!pattern(valueToMatch);\n          }\n        } catch (error) {\n          return false;\n        }\n      } else {\n        if (!config.acceptTruthyFunctionReturn) {\n          return pattern(valueToMatch) === true;\n        } else {\n          return !!pattern(valueToMatch);\n        }\n      }\n    }\n\n    if (config.strict) {\n      return pattern === valueToMatch;\n    }\n    return pattern == valueToMatch;\n  };\n\nexport const defaultResultGetter =\n  <TValue, TOutput>(\n    config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n  ) =>\n  (valueToMatch: TValue, pattern: Pattern<TValue>, result: any): TOutput => {\n    const getRegexResult = (\n      valueToMatch: TValue,\n      pattern: Pattern<TValue>,\n      replacement: any\n    ) => {\n      if (\n        typeof valueToMatch === \"string\" &&\n        typeof replacement === \"string\" &&\n        config.performReplaceOnRegex\n      ) {\n        return valueToMatch.replace(pattern, replacement);\n      }\n      return replacement;\n    };\n\n    const resultToBeSet =\n      config.runResultFunction && typeof result === \"function\"\n        ? result(valueToMatch)\n        : result;\n\n    return pattern instanceof RegExp\n      ? getRegexResult(valueToMatch, pattern, resultToBeSet)\n      : resultToBeSet;\n  };\n\nexport const createSwich =\n  <TValue, TOutput>({\n    returnMany: defaultReturnMany = false,\n    strict: defaultStrict = true,\n    acceptTruthyFunctionReturn: defaultAcceptTruthyFunctionReturn = true,\n    catchFunctionErrors: defaultCatchFunctionErrors = true,\n    performReplaceOnRegex: defaultPerformReplaceOnRegex = false,\n    runResultFunction: defaultRunResultFunction = true,\n    stopFallThrough: defaultStopFallThrough = false,\n    matcher: defaultMatcherValue = defaultMatcher,\n    resultGetter: defaultResultGetterValue = defaultResultGetter,\n  }: Object.Optional<Config<TValue, TOutput>> = {}) =>\n  (\n    patterns: CaseElements<TValue, TOutput>,\n    {\n      returnMany = defaultReturnMany,\n      strict = defaultStrict,\n      acceptTruthyFunctionReturn = defaultAcceptTruthyFunctionReturn,\n      catchFunctionErrors = defaultCatchFunctionErrors,\n      performReplaceOnRegex = defaultPerformReplaceOnRegex,\n      runResultFunction = defaultRunResultFunction,\n      stopFallThrough = defaultStopFallThrough,\n      matcher = defaultMatcherValue,\n      resultGetter = defaultResultGetterValue,\n    }: Object.Optional<Config<TValue, TOutput>> = {}\n  ) =>\n  (valueToMatch: TValue | boolean = true) => {\n    const config: BasicConfig<TValue, TOutput> = {\n      returnMany,\n      strict,\n      acceptTruthyFunctionReturn,\n      catchFunctionErrors,\n      performReplaceOnRegex,\n      runResultFunction,\n      stopFallThrough,\n    };\n\n    let found = false;\n    let result: TOutput | TOutput[] = returnMany ? [] : null;\n\n    const setResult = (value: TOutput, setFound = true) => {\n      found = setFound ? true : found;\n\n      if (returnMany) {\n        (result as TOutput[]).push(value);\n      } else {\n        result = value;\n      }\n    };\n\n    const verifyValue = matcher(config);\n    const getResult = resultGetter(config);\n\n    let fallingThrough = false;\n    patterns.forEach((matchArr, index) => {\n      const [pattern, result, fallthrough] = matchArr;\n      if (found && !returnMany && !fallingThrough) {\n        return;\n      }\n      if (matchArr.length === 1 && (!found || fallingThrough)) {\n        return setResult(\n          getResult(valueToMatch as TValue, undefined, pattern),\n          false\n        );\n      }\n\n      if (\n        matchArr.length !== 1 &&\n        ((fallingThrough && !stopFallThrough) ||\n          verifyValue(valueToMatch as TValue, pattern))\n      ) {\n        fallingThrough = !!fallthrough;\n        return setResult(getResult(valueToMatch as TValue, pattern, result));\n      }\n\n      fallingThrough = stopFallThrough ? false : !!fallthrough;\n    });\n\n    return result;\n  };\n\nexport const gt = (compareValue: number) => (value: number) =>\n  value > compareValue;\nexport const gte = (compareValue: number) => (value: number) =>\n  value >= compareValue;\nexport const lt = (compareValue: number) => (value: number) =>\n  value < compareValue;\nexport const lte = (compareValue: number) => (value: number) =>\n  value <= compareValue;\n\nconst defaultSwich = <TValue, TOutput>(\n  patterns: CaseElements<TValue, TOutput>,\n  config: Object.Optional<Config<TValue, TOutput>> = {}\n) => createSwich<TValue, TOutput>()(patterns, config);\n\nexport default defaultSwich;\n"],"sourceRoot":""}