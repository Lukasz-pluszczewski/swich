{"version":3,"sources":["webpack://Swich/webpack/universalModuleDefinition","webpack://Swich/webpack/bootstrap","webpack://Swich/webpack/runtime/define property getters","webpack://Swich/webpack/runtime/hasOwnProperty shorthand","webpack://Swich/webpack/runtime/make namespace object","webpack://Swich/./src/lib/index.ts"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","defaultMatcher","config","valueToMatch","pattern","RegExp","test","catchFunctionErrors","acceptTruthyFunctionReturn","error","strict","defaultResultGetter","result","resultToBeSet","runResultFunction","replacement","performReplaceOnRegex","replace","getRegexResult","swich","patterns","returnMany","stopFallThrough","matcher","resultGetter","found","setResult","setFound","push","verifyValue","getResult","fallingThrough","forEach","matchArr","index","fallthrough","length","undefined","gt","compareValue","gte","lt","lte","createSwich","defaultConfig"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Swich\"] = factory();\n\telse\n\t\troot[\"Swich\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Object } from \"ts-toolbelt\";\n\nexport type Pattern<TValue> =\n  | RegExp\n  | ((value: TValue) => boolean)\n  | ((value: TValue) => any)\n  | any;\nexport type Result<TValue, TOutput> = TOutput | ((param: TValue) => TOutput);\nexport type CaseElement<TValue, TOutput> = [\n  Pattern<TValue>,\n  Result<TValue, TOutput>,\n  true?\n];\nexport type DefaultCaseElement<TValue, TOutput> = [Result<TValue, TOutput>];\nexport type CaseElements<TValue, TOutput> = (\n  | CaseElement<TValue, TOutput>\n  | DefaultCaseElement<TValue, TOutput>\n)[];\n\nexport type Matcher<TValue, TOutput> = (\n  config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n) => (valueToMatch: TValue, pattern: Pattern<TValue>) => boolean;\nexport type ResultGetter<TValue, TOutput> = (\n  config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n) => (valueToMatch: TValue, pattern: Pattern<TValue>, result: any) => TOutput;\n\nexport type Config<TValue, TOutput> = {\n  returnMany: boolean;\n  strict: boolean;\n  acceptTruthyFunctionReturn: boolean;\n  catchFunctionErrors: boolean;\n  performReplaceOnRegex: boolean;\n  runResultFunction: boolean;\n  stopFallThrough: boolean;\n  matcher: Matcher<TValue, TOutput>;\n  resultGetter: ResultGetter<TValue, TOutput>;\n};\nexport type BasicConfig<TValue, TOutput> = Object.Omit<\n  Config<TValue, TOutput>,\n  \"matcher\" | \"resultGetter\"\n>;\n\nexport const defaultMatcher =\n  <TValue, TOutput>(config: BasicConfig<TValue, TOutput>) =>\n  (valueToMatch: TValue, pattern: Pattern<TValue>): boolean => {\n    if (pattern instanceof RegExp) {\n      return typeof valueToMatch === \"string\"\n        ? pattern.test(valueToMatch)\n        : false;\n    }\n    if (typeof pattern === \"function\") {\n      if (config.catchFunctionErrors) {\n        try {\n          if (!config.acceptTruthyFunctionReturn) {\n            return pattern(valueToMatch) === true;\n          } else {\n            return !!pattern(valueToMatch);\n          }\n        } catch (error) {\n          return false;\n        }\n      } else {\n        if (!config.acceptTruthyFunctionReturn) {\n          return pattern(valueToMatch) === true;\n        } else {\n          return !!pattern(valueToMatch);\n        }\n      }\n    }\n\n    if (config.strict) {\n      return pattern === valueToMatch;\n    }\n    return pattern == valueToMatch;\n  };\n\nexport const defaultResultGetter =\n  <TValue, TOutput>(\n    config: Object.Omit<Config<TValue, TOutput>, \"matcher\" | \"resultGetter\">\n  ) =>\n  (valueToMatch: TValue, pattern: Pattern<TValue>, result: TOutput): TOutput => {\n    const getRegexResult = (\n      valueToMatch: TValue,\n      pattern: Pattern<TValue>,\n      replacement: TOutput\n    ) => {\n      if (\n        typeof valueToMatch === \"string\" &&\n        typeof replacement === \"string\" &&\n        config.performReplaceOnRegex\n      ) {\n        return valueToMatch.replace(pattern, replacement);\n      }\n      return replacement;\n    };\n\n    const resultToBeSet =\n      config.runResultFunction && typeof result === \"function\"\n        ? result(valueToMatch)\n        : result;\n\n    return pattern instanceof RegExp\n      ? getRegexResult(valueToMatch, pattern, resultToBeSet)\n      : resultToBeSet;\n  };\n\ntype SwichReturnMany<TValue, TOutput> = (valueToMatch?: TValue | true) => TOutput[];\ntype SwichReturnOne<TValue, TOutput> = (valueToMatch?: TValue | true) => TOutput;\n\nfunction swich<TValue, TOutput>(\n  patterns: CaseElements<TValue, TOutput>,\n  config: Object.Optional<Config<TValue, TOutput>> & { returnMany: true }\n): SwichReturnMany<TValue, TOutput>;\n\nfunction swich<TValue, TOutput>(\n  patterns: CaseElements<TValue, TOutput>,\n  config?: Object.Optional<Config<TValue, TOutput>> & { returnMany?: false }\n): SwichReturnOne<TValue, TOutput>;\n\nfunction swich<TValue, TOutput>(\n    patterns: CaseElements<TValue, TOutput>,\n    {\n      returnMany = false,\n      strict = true,\n      acceptTruthyFunctionReturn = true,\n      catchFunctionErrors = true,\n      performReplaceOnRegex = false,\n      runResultFunction = true,\n      stopFallThrough = false,\n      matcher = defaultMatcher,\n      resultGetter = defaultResultGetter,\n    }: Object.Optional<Config<TValue, TOutput>> = {}\n  ) {\n  return (valueToMatch: TValue | true = true) => {\n    const config: BasicConfig<TValue, TOutput> = {\n      returnMany,\n      strict,\n      acceptTruthyFunctionReturn,\n      catchFunctionErrors,\n      performReplaceOnRegex,\n      runResultFunction,\n      stopFallThrough,\n    };\n\n    let found = false;\n    let result = (returnMany ? [] : null) as (TOutput[] | TOutput);\n\n    const setResult = (value: any, setFound = true) => {\n      found = setFound ? true : found;\n\n      if (returnMany) {\n        (result as TOutput[]).push(value);\n      } else {\n        (result as TOutput) = value;\n      }\n    };\n\n    const verifyValue = matcher(config);\n    const getResult = resultGetter(config);\n\n    let fallingThrough = false;\n    patterns.forEach((matchArr, index) => {\n      const [pattern, result, fallthrough] = matchArr;\n      if (found && !returnMany && !fallingThrough) {\n        return;\n      }\n      if (matchArr.length === 1 && (!found || fallingThrough)) {\n        return setResult(\n          getResult(valueToMatch as TValue, undefined, pattern),\n          false\n        );\n      }\n\n      if (\n        matchArr.length !== 1 &&\n        ((fallingThrough && !stopFallThrough) ||\n          verifyValue(valueToMatch as TValue, pattern))\n      ) {\n        fallingThrough = !!fallthrough;\n        return setResult(getResult(valueToMatch as TValue, pattern, result));\n      }\n\n      fallingThrough = stopFallThrough ? false : !!fallthrough;\n    });\n\n    return result;\n  }\n}\n\nexport const gt = (compareValue: number) => (value: number) =>\n  value > compareValue;\nexport const gte = (compareValue: number) => (value: number) =>\n  value >= compareValue;\nexport const lt = (compareValue: number) => (value: number) =>\n  value < compareValue;\nexport const lte = (compareValue: number) => (value: number) =>\n  value <= compareValue;\n\ntype CreateSwichReturnMany<TValue, TOutput> = <TValue, TOutput>(\n  patterns: CaseElements<TValue, TOutput>,\n  config?: Object.Optional<Config<TValue, TOutput>>\n) => SwichReturnMany<TValue, TOutput>\n\ntype CreateSwichReturnOne<TValue, TOutput> = <TValue, TOutput>(\n  patterns: CaseElements<TValue, TOutput>,\n  config?: Object.Optional<Config<TValue, TOutput>>\n) => SwichReturnOne<TValue, TOutput>\n\nexport function createSwich<TValue, TOutput>(defaultConfig: Object.Optional<Config<TValue, TOutput>> & { returnMany: true }): CreateSwichReturnMany<TValue, TOutput>;\n// @ts-ignore\nexport function createSwich<TValue, TOutput>(defaultConfig: Object.Optional<Config<TValue, TOutput>> & { returnMany?: false }): CreateSwichReturnOne<TValue, TOutput>;\n\nexport function createSwich<TDefaultValue, TDefaultOutput>(defaultConfig: Object.Optional<Config<TDefaultValue, TDefaultOutput>>) {\n  return <TValue = TDefaultValue, TOutput = TDefaultOutput>(\n    patterns: CaseElements<TValue, TOutput>,\n    config: Object.Optional<Config<TValue, TOutput>> = {}\n    // @ts-ignore\n  ) => swich(patterns, { ...defaultConfig, ...config });\n}\n\nexport default swich;\n"],"sourceRoot":""}